---
layout: post
title: Product Safety
image: /img/mspsds/industrialStrategy2.jpg
subtitle: Case Management System
---

![Energy Saving Advice Service](/img/mspsds/beisHeader.jpg)


Work in progress.

## Introduction

<!-- Also a BEIS project

I actually worked on another BEIS project in between (SME), the bench stuff (google maps).

I was part of a team building a case management system for the Office for Product Safety and Standards (OPSS) which is part of the Government Department for Business, Energy and Industrial Strategy (BEIS). This work was in preparation for when the UK leaves the European Union in March 2019.


to help the UK prepare to leave the 


Brexit project

Large team, 2xUR, 2xDUX, scrum master, project manager, product owner, tl, 6xdevs, tester.
Large team, understanding different roles and working together

Working offsite. -->



## Architecture

The frontend was written using [Ruby on Rails](https://rubyonrails.org/), a web application framework with a Model-View-Controller (MVC) pattern. When users visit the site, they are first authenticated by [Keycloak](https://www.keycloak.org/), an Identity and Access Management provider before being granted access. The site pulled business information from the [Companies House API](https://developer.companieshouse.gov.uk/api/docs/) and stored data in a [PostgreSQL](https://www.postgresql.org/) database. We had a [Redis](https://redis.io/) job queue which was responsible for running jobs in the background, such as scanning files for viruses or sending emails, without slowing down the user's experience.  We used [Elasticsearch](https://www.elastic.co/) to allow users to search and filter through the product and business data on our site.

![Architecture diagram](/img/mspsds/architecture.png)

All of these different components were set up in individual [Docker](https://www.docker.com/) containers and we used [Docker Compose](https://docs.docker.com/compose/overview/) to manage our multi-container setup. This approach allowed us to separate out the different concerns making it easier to reason about and to debug individual components during development.


### Ruby on Rails
The benefits of Ruby on Rails are that it does a lot of the heavy lifting for you and helps you to build simple things very quickly. For example, it has an idea of _resources_ within your system, a collection of similar objects, such as users or product investigations. Once you have declared a resource, Rails will create routes allowing you to do all of the CRUD operations (Create, Read, Update and Destroy). The routes that are generated are shown below for the _users_ resource.

{% highlight linenos %}
       Prefix Verb          URI Pattern                    Controller#Action
        users GET           /users(.:format)               users#index
              POST          /users(.:format)               users#create
     new_user GET           /users/new(.:format)           users#new
    edit_user GET           /users/:id/edit(.:format)      users#edit
         user GET           /users/:id(.:format)           users#show
              PATCH         /users/:id(.:format)           users#update
              PUT           /users/:id(.:format)           users#update
              DELETE        /users/:id(.:format)           users#destroy
{% endhighlight %}

The ability for Rails to take care of these tasks is sometimes called _RubyMagic_ and can be incredibly helpful. The downside is that the magic can be like a blackbox, making it very hard to debug problems and to understand what's happening under the hood. From my experience Rails lets you build very quickly if you stay on their _happy path_ but when you want to implement more complex functionality it can become very difficult and frustrating.


### Git Submodules

In this project we used [Git submodules](https://git-scm.com/book/en/v2/Git-Tools-Submodules) to store other Git repositories inside our main repository as subdirectories. We used this for two of the Keycloak components, one for styling the Keycloak pages and another for enabling the sms-authentication. For these components we forked existing third-party repositories and by including them as submodules we were able to work on them from within our project but to keep our Git commits separate.


## Key Features

### User Research

During this project there was a strong emphasis on user testing. This involved creating hypotheses about our users which were evaluated through regular rounds of user testing. The testing was normally carried out as one-to-one interviews between a user and a user researcher where the user was presented with a clickable prototype of our site.

Early on in the project the user researchers held a workshop for the team, teaching us how to sit in on these interviews and take notes effectively. They told us what to focus on and to only include objective observations and direct quotes so as not to bias the results with our own judgements. They also stressed that every member of the team should be involved with observing interviews as it was the best way to understand the user's perspective.

<!-- After the workshop I was able to sit in multiple interviews and I learnt 

then holding interviews where we would present the users with prototypes, then we would evaluate the results and use the learnings to improve the site before it went into production code.

Users first - one of the msost important things I learnt on this project
JIRA board of user stories
User research sessions
Rapid cycle of UR/UX/Dev -->

### Gov Prototype Kit

The clickable prototypes used for user testing were built using the [GOV.UK prototype kit](https://govuk-prototype-kit.herokuapp.com/docs). The kit uses the [Nunjucks](https://mozilla.github.io/nunjucks/templating.html) templating language for Javascript to pass data into the prototype to help make it feel more realistic for the user. It also uses the [GOV.UK design system](https://design-system.service.gov.uk/) which is a collection of styles and design patterns which help to make all GOV.UK services look consistent.

This is a very strong combination and means that it is extremely easy to build pages that are styled like the final product and that pass data in a realistic way. Below is a page from the prototype along with some of the Nunjucks code that was used to generate it.

![Product page from the prototype](/img/mspsds/productPage.png)
{% highlight jinja linenos %}
{% raw %}
// from product.html
{% block beforeContent %}
    {% include "includes/components/shared/page-banner.html" %}
    {% include "includes/components/product/product-navigation.html" %}
{% endblock %}
{% block content %}
    {% block casetitle %}
        {% include "includes/components/product/product-title.html" %}
    {% endblock %}

    {% block caseoverview %}
        {% include "includes/components/product/product-overview.html" %}
    {% endblock %}
{% endblock %}
{% endraw %}
{% endhighlight %}

{% highlight jinja linenos %}
{% raw %}
// from product-overview.html
 {% if prod.name %}
      {% set prodRows = (prodRows.push([
            { text: "Product name" },
            { text: prod.name  }
      ]), prodRows) %}
  {% endif %}

  {% if prod.brand %}
      {% set prodRows = (prodRows.push([
            { text: "Brand" },
            { text: prod.brand  }
      ]), prodRows) %}
  {% endif %}

  {% if prod.modelName %}
      {% set prodRows = (prodRows.push([
                { text: "Model name" },
                { text: prod.modelName  }
      ]), prodRows) %}
  {% endif %}
{% endraw %}
{% endhighlight %}

### Pair Programming

While I was working on this project I was part of a team of 6 developers, all with varying amounts of experience. This allowed us to work in pairs on a regular basis and I found that it was a great way to learn. When I was working with more senior devs I was able to ask questions and develop my understanding of the system. When I was working with more junior devs, I had to explain how the code worked and what approaches I thought we should take. This really made me think and helped me to solidify my own understanding of what was going on. I also found that we were able to work faster in pairs, to catch more bugs and typos and also to learn shortcuts and tools from each other.

### Inheritance
<!-- Inheritance for audit activities -->



### Coding in the Open

### Coveralls
<!-- Code coverage for enforcing tests -->

### Show and Tell


<!-- Setting up 2FA with Keycloak and Notify -->
## Conclusion


 
